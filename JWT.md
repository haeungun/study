# JWT
JSON 포맷을 이용한 Claim 기반의 Web Token.<br>
JSON Web Token(JWT)은 웹표준으로서 두 개체에서 JSON 객체를 사용하여 가볍고 자가수용적(Self-contained)인 방식으로 정보를 안정성 있게 전달해준다. 

### 수많은 프로그래밍 언어에서 지원된다
JWT 는 C, Java, Python, C++, R, C#, PHP, JavaScript, Ruby, Go, Swift 등 대부분의 주류 프로그래밍 언어에서 지원된다.

### 자가수용적이다
JWT 는 필요한 모든 정보를 자체적으로 지니고 있다. 
JWT 시스템에서 발급된 토큰은, 토큰에 대한 기본정보, 전달 할 정보 (로그인시스템에서는 유저 정보), 
그리고 토큰이 검증됐다는것을 증명해주는 signature 를 포함하고 있다.

### 쉽게 전달될 수 있다
JWT 는 자가수용적이므로, 두 개체 사이에서 손쉽게 전달될 수 있다. 웹서버의 경우 HTTP 의 헤더에 넣어서 전달 할 수도 있고, 
URL 의 파라미터로 전달 할 수도 있다.


## 왜 토큰을 사용하게 되었을까?

### 서버 기반 인증의 문제점

- 세션
````
유저가 인증을 할 때, 서버는 이 기록을 서버에 저장 해야 한다. 이를 세션 이라고 부른다. 대부분의 경우엔 메모리에 이를 저장하는데, 
로그인 중인 유저의 수가 늘어난다면 서버의 램이 과부하 될 수 있다. 이를 피하기 위해 세션을 데이터베이스 시스템에 저장하는 방식도 있지만, 
이 또한 유저 수가 많으면 데이터베이스의 성능에 무리를 줄 수 있다.
````
- 확장성
````
세션을 사용하면 서버를 확장하는 것이 어려워 진다. 세션을 사용하면서 분산된 시스템을 설계하는 것이 불가능한 것은 
아니지만 과정이 매우 복잡해진다. 
````
> 여기서 서버의 확장이란, 단순이 서버의 사양을 업그레이드 하는 것이 아니라 더 많은 트래픽을 감당하기 
위하여 여러개의 프로세스를 돌리거나, 여러대의 서버 컴퓨터를 추가하는 것을 의미한다.
- CORS(Cross-Origin Resource Sharing)
````
웹 어플리케이션에서 세션을 관리 할 때 자주 사용되는 쿠키는 단일 도메인 및 서브 도메인에서만 작동하도록 설계 되어있다. 
따라서 쿠키를 여러 도메인에서 관리하는 것은 번거롭다. 
````

- CSRF
- Not only web, Mobile
- Rest API

### 토큰 기반 시스텝의 작동 원리
토큰 기반 시스템은 stateless 하다. 즉 상태를 유지하지 않는다. 이 시스템에서는 유저의 인증 정보를 서버나 세션에 담아두지 않는다. 
이 개념 하나만으로도 서버에서 유저의 인증 정보를 서버측에 담아둠으로서 발생하는 많은 문제점이 해결된다. <br>
세션이 존재하지 않으니, 유저들이 로그인 되어 있는지 안되어 있는지 신경을 쓰지 않고 서버를 손쉽데 확장할 수 있다. <br><br>

토큰 기반 시스템의 구현 방식은 시스템마다 크고 작은 차이가 있지만 대략적으로 다음과 같다 
1. 유저가 아이디와 비밀번호로 **로그인**을 한다.
2. 서버측에서 해당 **계정정보를 검증**한다.
3. 계정정보가 정확하다면, 서버측에서 유저에게 signed **토큰을 발급**해준다.
> 여기서 signed 의 의미는 해당 토큰이 서버에서 정상적으로 발급된 토큰임을 증명하는 signature 를 지니고 있다는 것이다.
4. 클라이언트 측에서 전달받은 **토큰을 저장** 해두고, 서버에 요청을 할 때마다, 해당 **토큰을 함께 서버에 전달**한다. 
5. 서버는 **토큰을 검증**하고, **요청에 응답**한다. 
<br>
웹 서버에서 토큰을 서버에 전달할 때에는 HTTP 요청의 헤더에 토큰값을 포함시켜서 전달한다. 

### 토큰의 장점
- 무상태(stateless)이며 확장성(scalability)이 있다.
````
이는 토큰 기반 인증 시스템의 중요한 속성이다. 토큰은 클라이언트 사이드에 저장되기 때문에 완전히 stateless 하며, 서버를 확장하기에 매우 
적합한 환경을 제공한다. 만약에 세션을 서버측에 저장하고 있고, 서버를 여러대 사용하여 요청을 분산하였다면, 어떤 유저가 로그인 했을 때 그 유저는 처음 로그인
했었던 그 서버에만 요청을 보내도록 설정을 해야 한다. 하지만 토큰을 사용하면 어떤 서버로 요청이 들어가든 상관이 없게 된다. 
````
- 보안성
````
클라이언트가 서버에 요청을 보낼 때, 더 이상 쿠키를 전달하지 않으므로 쿠키를 사용함으로 인해 발생하는 취약점이 사라진다. 
하지만, 토큰을 사용하는 환경에서도 취약점이 존재할 수 있으니 항상 조심 ! 
````
- 확장성(Extensibility)
````
여기서의 확장성은 scalability 와는 또 다른 개념이다. scalability 가 서버를 확장하는 것을 의미한다면, extensibility 는 로그인 정보가 
사용되는 분야를 확장하는 것을 의미한다. 토큰을 사용하여 다른 서비스에서도 권한을 공유할 수 있다. 예를 들어서, ooo 이라는 웹 서비스는 Facebook, 
LinkedIn, Github, Google 계정으로 로그인을 할 수 있다. 토큰 기반 시스템에서는 토큰에 선택적인 권한만 부여하여 발급을 할 수 있다.<br>
예를 들어서, ooo 에 Facebook 계정으로 로그인을 했다면 프로필 정보를 가져오는 권한은 있어도 포스트를 작성할 수 있는 권한은 없을 수 있다.
````
- 여러 플랫폼 및 도메인
````
일반적으로 어플리케이션과 서비스의 규모가 커지면 여러 디바이스를 호환시키고, 더 많은 종류의 서비스를 제공한다. 토큰을 사용한다면, 그 어떤 디바이스나 
도메인에서도 토큰만 유효하다면 요청이 정상적으로 처리된다.<br>
이런 구조에서는 aeests 파일들(이미자, css, js, html 파일 등)은 모두 CDN 에서 제공을 하도록 하고, 서버측에서는 오직 API 만 다루도록 하도록 
설계할 수 있다. 
````

### 웹 표준 기반
토큰 기반 인증 시스템의 구현체인 JWT 는 웹표준에 등록되어 있다. 따라서 여러 환경에서 지원이 되며 수많은 회사의 인프라스트럭쳐에서 사용되고 있다. 

## JWT 는 어떤 상황에서 사용될까?
- 회원인증
````
JWT 를 사용하는 가장 흔한 시나리오이다. 유저가 로그인을 하면, 서버는 유저의 정보에 기반한 토큰을 발급하여 유저에게 전달해준다. 그 후, 
유저가 서버에 요청을 할 때마다 JWT 를 포함하여 전달한다. 서버가 클라이언트에게 요청을 받을 때마다 해당 토큰이 유효하고 인증됐는지 검증을 하고 
유저가 요청한 작업에 권한이 있는지 확인하여 작업을 처리한다. <br>
서버측에서는 유저의 세션을 유지할 필요가 없다. 즉 유저가 로그인 되어 있는지 안되어 있는지 신경 쓸 필요가 없고, 유저가 요청을 했을 때 토큰만 
확인하면 되니, 세션 관리가 필요없어서 서버 자원을 많이 아낄 수 있다.
````
- 정보전달
````
JWT 는 두 개체 사이에서 안정성있게 정보를 교환하기에 좋은 방법이다. 그 이유는 정보가 sign 이 되어있기 때문에 정보를 보낸이가 바뀌진 않았는지, 
또 정보가 도중에 조작되지는 않았는지 검증할 수 있다. 
````

## JWT 의 생김새
JWT 는 ```.```을 구분자로 3가지의 문자열도 되어 있다. 
````
aaaaa.bbbbb.ccccc
````
> a: 헤더, b: 내용(payload), c: 서명

### 헤더(Header)
Header 는 두 가지의 정보를 지니고 있다. 
- type : 토큰의 타입을 지정한다. 
- alg : 해싱 알고리즘을 지정한다. 이 알고리즘은 토큰을 검증할 때 사용되는 signature 부분에서 사용된다. 

````javascript
{
   "typ": "JWT",
   "alg": "HS256"
}
````

### 정보(Payload)
Payload 부분에는 토큰에 담을 정보가 들어있다. 여기에 담는 정보의 한 '조각'을 클레임(claim) 이라고 부르고, 이는 name/value 의 한 쌍으로 
이루어져있다. 토큰에는 여러 개의 클레임들을 넣을 수 있다.<br>
클레임의 종류에는 다음과 같은 것들이 있다.
- Reserved claims
- Public claims
- Private claims
> 클레임은 사용자의 속성, 프로퍼티를 말한다. 
클레임 방식의 토큰을 이용해서 요청을 받는 서버나 서비스 입장에서 
이 서비스를 호출한 사용자에 대한 추가 정보가 이미 다 토큰 안에 들어가 있기 때문에 다른 곳에서 가져올 필요가 없다.
따라서 토큰을 사용하는 API 서버 입장에서는 API 요청을 검증하기 위해서 토큰을 가지고 사용자 정보를 별도로 계정 시스템 등에서 조회할 필요가 없다. 

### 서명(Signature)
JSON Web Token 의 마지막 부분은 바로 서명(signature)이다. 이 서명은 Header + Payload 를 합친 후 주어진 비밀키와 함께 Header 의 
해싱 알고리즘으로 인코딩 하여 생성한다. 


## JWT 의 단점
- Self-contained
````
토큰 자체에 정보가 있다는 사실은 양날의 검이 될 수 있다.
1. 토큰 자체 Payload 에 Claim set 을 저장하기 때문에 정보가 많아질 수록 토큰의 길이가 늘어나 부하를 줄 수 있다.
2. payload 자체는 암호화되지 않고 base64 로 인코딩한 데이터이다. 중간에 payload 를 탈취하면 디코딩 데이터를 볼 수 있다.
  ->  JWE 를 통해 암호화  payload 에 중요 데이터를 넣지 않아야 한다.
````
- Stateless 
````
무상태성이 항상 편리하지는 않다. 토큰은 한번 만들면 서버에서 제어가 불가능하다. 임의로 토큰을 삭제할 수 있는 방법이 없기 때문에 토큰 만료 시간을 꼭 
넣어주는게 좋다.
````
- Store token 
````
토큰은 클라이언트 사이드에서 관리해야하기 때문에 토큰을 저장해야한다.
````
